{"version":3,"sources":["EntriesTableModelImpl.ts"],"names":["EntriesTableModelImpl","_backendMap","_authClient","_disposed","_historyIndex","_history","_addNewItemMutex","Mutex","_entries","Map","_isCreatingNewEntry","_settings","_serializedSettings","_descriptions","_subscriptions","Set","addNewItemThrottled","_","throttle","addNewItem","a","omitHistory","acquire","release","_tryFindVacantEntry","_createNewEntry","undefined","entry","onUpdate","clear","setFocused","setInitiallyCollapsed","setCreationTime","Date","now","sync","state","AuthStates","SIGNED_IN","waitForStateChange","getAllKeys","keys","newEntries","Array","from","forEach","x","has","id","get","description","EntryStatus","DELETED","outdated","EntryModel","size","length","HIDDEN","LOADING","set","assert","setDescription","promises","push","_fetchSettings","reverse","data","_fetch","_onEntriesChanged","Promise","all","onSettingsUpdate","debounce","settings","setSettings","stringify","key","prevEntry","_sendEntryToBackend","_addHistoryItem","_syncLoop","setTimeout","content","console","error","isDataLoaded","delete","JSON","parse","left","right","Error","message","this","callback","add","_getFilteredEntriesArray","canUndo","canRedo","lastVacantEntry","createKey","newKey","newEntry","old","new","historyItem","oldEntry","slice","descriptionPromise","dataPromise","getSettings","serializedSettings","Settings","values","filter","entries"],"mappings":"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","file":"static/js/7.53315ee8.chunk.js","sourcesContent":["import { BackendMultiplexor } from \"./BackendQuotaSavers/BackendMultiplexor\";\nimport { AuthStates, AuthClient } from \"./AuthClient\";\nimport { Settings } from \"./Settings\";\nimport { EntryStatus, EntryModel } from \"./EntryModel\";\nimport _ from \"lodash\";\nimport { Mutex } from \"async-mutex\";\nimport {\n  EntriesTableModel,\n  EntriesSubscriptionCallback,\n} from \"./EntriesTableModel\";\nimport assert from \"assert\";\n\ninterface HistoryItem {\n  old: EntryModel;\n  new: EntryModel;\n}\n\nexport class EntriesTableModelImpl implements EntriesTableModel {\n  private _disposed = false;\n  private _historyIndex = 0;\n  private _history: HistoryItem[] = [];\n  private _addNewItemMutex = new Mutex();\n\n  // |_entries| is in reverse order.\n  // It is natural for |Map| to add new items to the end, but\n  // in |EntriesTable| new items belong to the top.\n  private _entries: Map<string, EntryModel> = new Map();\n  private _isCreatingNewEntry = false;\n\n  private _settings?: Settings;\n  private _serializedSettings = \"\";\n  private _descriptions: Map<string, string> = new Map();\n  private _subscriptions: Set<EntriesSubscriptionCallback> = new Set();\n\n  constructor(\n    private _backendMap: BackendMultiplexor,\n    private _authClient: AuthClient\n  ) {\n    this._syncLoop();\n  }\n\n  dispose(): void {\n    this._disposed = true;\n    this._subscriptions = new Set();\n  }\n\n  subscribe(callback: EntriesSubscriptionCallback): void {\n    this._subscriptions.add(callback);\n    if (this._entries.size > 0)\n      callback(this._getFilteredEntriesArray(), this._settings, {\n        canUndo: false,\n        canRedo: false,\n      });\n  }\n\n  unsubscribe(callback: EntriesSubscriptionCallback): void {\n    this._subscriptions.delete(callback);\n  }\n\n  addNewItemThrottled = _.throttle(() => {\n    this.addNewItem();\n  }, 500);\n\n  addNewItem = async (omitHistory = false): Promise<void> => {\n    const release = await this._addNewItemMutex.acquire();\n\n    const entry = this._tryFindVacantEntry() || (await this._createNewEntry());\n\n    if (entry == undefined) return;\n\n    this.onUpdate(\n      entry\n        .clear()\n        .setFocused(true)\n        .setInitiallyCollapsed(true)\n        .setCreationTime(new Date(Date.now())),\n      omitHistory\n    );\n\n    release();\n  };\n\n  // If user deletes entries from top of the table than keys assigned to these\n  // entries can be reused.\n  // This function returns such entry if it exists.\n  _tryFindVacantEntry(): EntryModel | undefined {\n    let lastVacantEntry: EntryModel | undefined = undefined;\n    this._entries.forEach((entry) => {\n      if (entry.data === EntryStatus.DELETED) {\n        if (lastVacantEntry == undefined) lastVacantEntry = entry;\n      } else {\n        lastVacantEntry = undefined;\n      }\n    });\n\n    return lastVacantEntry;\n  }\n\n  // If there is no deleted entry to reuse the only option is creating a new one.\n  async _createNewEntry(): Promise<EntryModel | undefined> {\n    if (this._isCreatingNewEntry) {\n      return;\n    }\n    this._isCreatingNewEntry = true;\n\n    const newKey = await this._backendMap.createKey();\n\n    assert(this._isCreatingNewEntry);\n    this._isCreatingNewEntry = false;\n\n    const newEntry = new EntryModel(newKey, EntryStatus.DELETED, \"\");\n    this._entries.set(newKey, newEntry);\n    await this._sendEntryToBackend(newEntry);\n\n    return newEntry;\n  }\n\n  undo(): void {\n    if (this._historyIndex === 0) return;\n\n    this._historyIndex--;\n\n    let entry = this._history[this._historyIndex].old;\n    if (entry.data !== EntryStatus.DELETED) {\n      entry = entry.setFocused(true);\n      if (this._history[this._historyIndex].new.data === EntryStatus.DELETED) {\n        entry = entry.setInitiallyCollapsed(true);\n      }\n    }\n\n    this._entries.set(entry.key, entry);\n    this._sendEntryToBackend(entry);\n    this._onEntriesChanged();\n  }\n\n  redo(): void {\n    if (this._historyIndex >= this._history.length) return;\n\n    const historyItem = this._history[this._historyIndex++];\n    let entry = historyItem.new;\n    if (entry.data !== EntryStatus.DELETED) {\n      entry = entry.setFocused(true);\n      if (historyItem.old.data === EntryStatus.DELETED) {\n        entry = entry.setInitiallyCollapsed(true);\n      }\n    }\n\n    this._entries.set(entry.key, entry);\n    this._sendEntryToBackend(entry);\n    this._onEntriesChanged();\n  }\n\n  sync = async (): Promise<void> => {\n    if (this._disposed) return;\n\n    while (this._authClient.state !== AuthStates.SIGNED_IN) {\n      await this._authClient.waitForStateChange();\n    }\n\n    const keys = await this._backendMap.getAllKeys();\n\n    const newEntries = new Map();\n\n    Array.from(keys).forEach((x) => {\n      let entry;\n      if (this._entries.has(x.id)) {\n        entry = this._entries.get(x.id);\n      } else if (x.description === EntryStatus.DELETED) {\n        x.outdated = false;\n        entry = new EntryModel(x.id, EntryStatus.DELETED, \"\");\n      } else {\n        x.outdated = true;\n        entry = new EntryModel(\n          x.id,\n          newEntries.size < keys.length - 30\n            ? EntryStatus.HIDDEN\n            : EntryStatus.LOADING,\n          x.description ?? \"\"\n        );\n        this._descriptions.set(x.id, x.description ?? \"\");\n      }\n\n      assert(!!entry);\n      if (x.description !== this._descriptions.get(x.id)) {\n        entry = entry.setDescription(x.description ?? \"\");\n        this._descriptions.set(x.id, x.description ?? \"\");\n      }\n      newEntries.set(x.id, entry);\n    });\n\n    const promises: Promise<void>[] = [];\n    if (this._settings == undefined) promises.push(this._fetchSettings());\n\n    keys.reverse().forEach((x) => {\n      if (x.outdated && newEntries.get(x.id).data !== EntryStatus.HIDDEN) {\n        promises.push(this._fetch(x.id));\n      }\n    });\n\n    this._entries = newEntries;\n\n    if (this._entries.size === 0) {\n      await this.addNewItem(true);\n      return;\n    }\n\n    this._onEntriesChanged();\n\n    await Promise.all(promises);\n  };\n\n  onSettingsUpdate = _.debounce((settings) => {\n    this._settings = settings;\n    this._onEntriesChanged();\n    this._backendMap.setSettings(settings.stringify());\n  }, 1000);\n\n  onUpdate = (entry: EntryModel, omitHistory = false): void => {\n    if (!this._entries.has(entry.key)) return;\n\n    const prevEntry = this._entries.get(entry.key);\n    assert(!!prevEntry);\n\n    if (entry.data === EntryStatus.LOADING) {\n      if (prevEntry.data === EntryStatus.HIDDEN) {\n        this._fetch(entry.key);\n        this._entries.set(entry.key, entry);\n      }\n      return;\n    }\n\n    this._sendEntryToBackend(entry);\n    if (!omitHistory) this._addHistoryItem(entry);\n    this._entries.set(entry.key, entry);\n\n    this._onEntriesChanged();\n  };\n\n  _syncLoop = async (): Promise<void> => {\n    if (this._disposed) return;\n    await this.sync();\n    setTimeout(this._syncLoop, 15000);\n  };\n\n  _addHistoryItem(newEntry: EntryModel): void {\n    const oldEntry = this._entries.get(newEntry.key);\n    if (oldEntry == undefined || !oldEntry.isDataLoaded()) {\n      return;\n    }\n\n    this._history = this._history.slice(0, this._historyIndex);\n    this._history.push({\n      old: oldEntry,\n      new: newEntry,\n    });\n    this._historyIndex = this._history.length;\n  }\n\n  async _sendEntryToBackend(entry: EntryModel): Promise<void> {\n    let descriptionPromise = null;\n    if (entry.description !== this._descriptions.get(entry.key)) {\n      descriptionPromise = this._backendMap.setDescription(\n        entry.key,\n        entry.description\n      );\n      this._descriptions.set(entry.key, entry.description);\n    }\n\n    let dataPromise = null;\n    if (entry.isDataLoaded())\n      dataPromise = this._backendMap.set(entry.key, JSON.stringify(entry.data));\n\n    await Promise.all([descriptionPromise, dataPromise]);\n  }\n\n  async _fetchSettings(): Promise<void> {\n    const serializedSettings = await this._backendMap.getSettings();\n\n    if (serializedSettings == \"\") {\n      this.onSettingsUpdate(new Settings(\"\"));\n      return;\n    }\n\n    if (this._serializedSettings === serializedSettings) return;\n    this._serializedSettings = serializedSettings;\n    this._settings = new Settings(serializedSettings);\n    this._onEntriesChanged();\n  }\n\n  _fetch = async (key: string): Promise<void> => {\n    const content = await this._backendMap.get(key);\n\n    if (!this._entries.has(key)) {\n      console.error(\"Entry for fetch doesn't exist anymore. \" + key);\n      return;\n    }\n\n    if (content === undefined) {\n      console.error(\"Key \" + key + \" is missing\");\n      const entry = this._entries.get(key);\n      if (entry != undefined && !entry.isDataLoaded()) {\n        this._entries.delete(key);\n        this._onEntriesChanged();\n      }\n      return;\n    }\n\n    try {\n      if (content === \"\") {\n        const entry = new EntryModel(key, EntryStatus.DELETED, \"\");\n        this._addHistoryItem(entry);\n        this._entries.set(key, entry);\n      } else {\n        const data = JSON.parse(content);\n\n        if (\n          data !== EntryStatus.DELETED &&\n          (data.left == null || data.right == null)\n        ) {\n          throw new Error(\"bad format \" + content);\n        }\n\n        if (\n          data === EntryStatus.DELETED &&\n          this._descriptions.get(key) !== EntryStatus.DELETED\n        ) {\n          this._backendMap.setDescription(key, EntryStatus.DELETED);\n        }\n\n        const entry = new EntryModel(\n          key,\n          data,\n          this._descriptions.get(key) ?? \"\"\n        );\n\n        this._addHistoryItem(entry);\n        this._entries.set(key, entry);\n      }\n    } catch (e) {\n      console.error(e.message + \" \" + key + \" \" + content);\n      const entry = this._entries.get(key);\n      if (entry != undefined && !entry.isDataLoaded()) {\n        this._entries.delete(key);\n        this._onEntriesChanged();\n      }\n      return;\n    }\n\n    this._onEntriesChanged();\n  };\n\n  _getFilteredEntriesArray(): EntryModel[] {\n    return Array.from(this._entries.values())\n      .reverse()\n      .filter((x) => x.data !== EntryStatus.DELETED && x.key !== null);\n  }\n\n  _onEntriesChanged(): void {\n    const entries = this._getFilteredEntriesArray();\n    this._subscriptions.forEach((callback) => {\n      callback(entries, this._settings, {\n        canRedo: this._history.length > this._historyIndex,\n        canUndo: this._history.length > 0 && this._historyIndex > 0,\n      });\n    });\n  }\n}\n"],"sourceRoot":""}