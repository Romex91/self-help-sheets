{"version":3,"sources":["EntriesTableModelImpl.ts"],"names":["EntriesTableModelImpl","_backendMap","_authClient","_disposed","_historyIndex","_history","_addNewItemMutex","Mutex","_entries","Map","_isCreatingNewEntry","_settings","_serializedSettings","_descriptions","_subscriptions","Set","addNewItemThrottled","_","throttle","addNewItem","a","omitHistory","acquire","release","_tryFindVacantEntry","_createNewEntry","undefined","entry","onUpdate","clear","setFocused","setInitiallyCollapsed","setCreationTime","Date","now","undo","old","data","EntryStatus","DELETED","new","set","key","_sendEntryToBackend","_onEntriesChanged","redo","length","historyItem","sync","state","AuthStates","SIGNED_IN","waitForStateChange","getAllKeys","keys","newEntries","Array","from","forEach","x","has","id","get","description","outdated","EntryModel","size","HIDDEN","LOADING","assert","setDescription","promises","push","_fetchSettings","reverse","_fetch","Promise","all","onSettingsUpdate","debounce","settings","setSettings","stringify","prevEntry","_addHistoryItem","_syncLoop","setTimeout","content","console","error","isDataLoaded","delete","JSON","parse","left","right","Error","message","this","callback","add","_getFilteredEntriesArray","canUndo","canRedo","lastVacantEntry","createKey","newKey","newEntry","oldEntry","slice","descriptionPromise","dataPromise","getSettings","serializedSettings","Settings","values","filter","entries"],"mappings":"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","file":"static/js/7.dd3937ff.chunk.js","sourcesContent":["import { BackendMultiplexor } from \"./BackendQuotaSavers/BackendMultiplexor\";\nimport { AuthStates, AuthClient } from \"./AuthClient\";\nimport { Settings } from \"./Settings\";\nimport { EntryStatus, EntryModel } from \"./EntryModel\";\nimport _ from \"lodash\";\nimport { Mutex } from \"async-mutex\";\nimport {\n  EntriesTableModel,\n  EntriesSubscriptionCallback,\n} from \"./EntriesTableModel\";\nimport assert from \"assert\";\n\ninterface HistoryItem {\n  old: EntryModel;\n  new: EntryModel;\n}\n\nexport class EntriesTableModelImpl implements EntriesTableModel {\n  private _disposed = false;\n  private _historyIndex = 0;\n  private _history: HistoryItem[] = [];\n  private _addNewItemMutex = new Mutex();\n\n  // |_entries| is in reverse order.\n  // It is natural for |Map| to add new items to the end, but\n  // in |EntriesTable| new items belong to the top.\n  private _entries: Map<string, EntryModel> = new Map();\n  private _isCreatingNewEntry = false;\n\n  private _settings?: Settings;\n  private _serializedSettings = \"\";\n  private _descriptions: Map<string, string> = new Map();\n  private _subscriptions: Set<EntriesSubscriptionCallback> = new Set();\n\n  constructor(\n    private _backendMap: BackendMultiplexor,\n    private _authClient: AuthClient\n  ) {\n    this._syncLoop();\n  }\n\n  dispose(): void {\n    this._disposed = true;\n    this._subscriptions = new Set();\n  }\n\n  subscribe(callback: EntriesSubscriptionCallback): void {\n    this._subscriptions.add(callback);\n    if (this._entries.size > 0)\n      callback(this._getFilteredEntriesArray(), this._settings, {\n        canUndo: false,\n        canRedo: false,\n      });\n  }\n\n  unsubscribe(callback: EntriesSubscriptionCallback): void {\n    this._subscriptions.delete(callback);\n  }\n\n  addNewItemThrottled = _.throttle(() => {\n    this.addNewItem();\n  }, 500);\n\n  addNewItem = async (omitHistory = false): Promise<void> => {\n    const release = await this._addNewItemMutex.acquire();\n\n    const entry = this._tryFindVacantEntry() || (await this._createNewEntry());\n\n    if (entry == undefined) return;\n\n    this.onUpdate(\n      entry\n        .clear()\n        .setFocused(true)\n        .setInitiallyCollapsed(true)\n        .setCreationTime(new Date(Date.now())),\n      omitHistory\n    );\n\n    release();\n  };\n\n  // If user deletes entries from top of the table than keys assigned to these\n  // entries can be reused.\n  // This function returns such entry if it exists.\n  _tryFindVacantEntry(): EntryModel | undefined {\n    let lastVacantEntry: EntryModel | undefined = undefined;\n    this._entries.forEach((entry) => {\n      if (entry.data === EntryStatus.DELETED) {\n        if (lastVacantEntry == undefined) lastVacantEntry = entry;\n      } else {\n        lastVacantEntry = undefined;\n      }\n    });\n\n    return lastVacantEntry;\n  }\n\n  // If there is no deleted entry to reuse the only option is creating a new one.\n  async _createNewEntry(): Promise<EntryModel | undefined> {\n    if (this._isCreatingNewEntry) {\n      return;\n    }\n    this._isCreatingNewEntry = true;\n\n    const newKey = await this._backendMap.createKey();\n\n    assert(this._isCreatingNewEntry);\n    this._isCreatingNewEntry = false;\n\n    const newEntry = new EntryModel(newKey, EntryStatus.DELETED, \"\");\n    this._entries.set(newKey, newEntry);\n    await this._sendEntryToBackend(newEntry);\n\n    return newEntry;\n  }\n\n  undo = (): void => {\n    if (this._historyIndex === 0) return;\n\n    this._historyIndex--;\n\n    let entry = this._history[this._historyIndex].old;\n    if (entry.data !== EntryStatus.DELETED) {\n      entry = entry.setFocused(true);\n      if (this._history[this._historyIndex].new.data === EntryStatus.DELETED) {\n        entry = entry.setInitiallyCollapsed(true);\n      }\n    }\n\n    this._entries.set(entry.key, entry);\n    this._sendEntryToBackend(entry);\n    this._onEntriesChanged();\n  }\n\n  redo = (): void => {\n    if (this._historyIndex >= this._history.length) return;\n\n    const historyItem = this._history[this._historyIndex++];\n    let entry = historyItem.new;\n    if (entry.data !== EntryStatus.DELETED) {\n      entry = entry.setFocused(true);\n      if (historyItem.old.data === EntryStatus.DELETED) {\n        entry = entry.setInitiallyCollapsed(true);\n      }\n    }\n\n    this._entries.set(entry.key, entry);\n    this._sendEntryToBackend(entry);\n    this._onEntriesChanged();\n  }\n\n  sync = async (): Promise<void> => {\n    if (this._disposed) return;\n\n    while (this._authClient.state !== AuthStates.SIGNED_IN) {\n      await this._authClient.waitForStateChange();\n    }\n\n    const keys = await this._backendMap.getAllKeys();\n\n    const newEntries = new Map();\n\n    Array.from(keys).forEach((x) => {\n      let entry;\n      if (this._entries.has(x.id)) {\n        entry = this._entries.get(x.id);\n      } else if (x.description === EntryStatus.DELETED) {\n        x.outdated = false;\n        entry = new EntryModel(x.id, EntryStatus.DELETED, \"\");\n      } else {\n        x.outdated = true;\n        entry = new EntryModel(\n          x.id,\n          newEntries.size < keys.length - 30\n            ? EntryStatus.HIDDEN\n            : EntryStatus.LOADING,\n          x.description ?? \"\"\n        );\n        this._descriptions.set(x.id, x.description ?? \"\");\n      }\n\n      assert(!!entry);\n      if (x.description !== this._descriptions.get(x.id)) {\n        entry = entry.setDescription(x.description ?? \"\");\n        this._descriptions.set(x.id, x.description ?? \"\");\n      }\n      newEntries.set(x.id, entry);\n    });\n\n    const promises: Promise<void>[] = [];\n    if (this._settings == undefined) promises.push(this._fetchSettings());\n\n    keys.reverse().forEach((x) => {\n      if (x.outdated && newEntries.get(x.id).data !== EntryStatus.HIDDEN) {\n        promises.push(this._fetch(x.id));\n      }\n    });\n\n    this._entries = newEntries;\n\n    if (this._entries.size === 0) {\n      await this.addNewItem(true);\n      return;\n    }\n\n    this._onEntriesChanged();\n\n    await Promise.all(promises);\n  };\n\n  onSettingsUpdate = _.debounce((settings) => {\n    this._settings = settings;\n    this._onEntriesChanged();\n    this._backendMap.setSettings(settings.stringify());\n  }, 1000);\n\n  onUpdate = (entry: EntryModel, omitHistory = false): void => {\n    if (!this._entries.has(entry.key)) return;\n\n    const prevEntry = this._entries.get(entry.key);\n    assert(!!prevEntry);\n\n    if (entry.data === EntryStatus.LOADING) {\n      if (prevEntry.data === EntryStatus.HIDDEN) {\n        this._fetch(entry.key);\n        this._entries.set(entry.key, entry);\n      }\n      return;\n    }\n\n    this._sendEntryToBackend(entry);\n    if (!omitHistory) this._addHistoryItem(entry);\n    this._entries.set(entry.key, entry);\n\n    this._onEntriesChanged();\n  };\n\n  _syncLoop = async (): Promise<void> => {\n    if (this._disposed) return;\n    await this.sync();\n    setTimeout(this._syncLoop, 15000);\n  };\n\n  _addHistoryItem(newEntry: EntryModel): void {\n    const oldEntry = this._entries.get(newEntry.key);\n    if (oldEntry == undefined || !oldEntry.isDataLoaded()) {\n      return;\n    }\n\n    this._history = this._history.slice(0, this._historyIndex);\n    this._history.push({\n      old: oldEntry,\n      new: newEntry,\n    });\n    this._historyIndex = this._history.length;\n  }\n\n  async _sendEntryToBackend(entry: EntryModel): Promise<void> {\n    let descriptionPromise = null;\n    if (entry.description !== this._descriptions.get(entry.key)) {\n      descriptionPromise = this._backendMap.setDescription(\n        entry.key,\n        entry.description\n      );\n      this._descriptions.set(entry.key, entry.description);\n    }\n\n    let dataPromise = null;\n    if (entry.isDataLoaded())\n      dataPromise = this._backendMap.set(entry.key, JSON.stringify(entry.data));\n\n    await Promise.all([descriptionPromise, dataPromise]);\n  }\n\n  async _fetchSettings(): Promise<void> {\n    const serializedSettings = await this._backendMap.getSettings();\n\n    if (serializedSettings == \"\") {\n      this.onSettingsUpdate(new Settings(\"\"));\n      return;\n    }\n\n    if (this._serializedSettings === serializedSettings) return;\n    this._serializedSettings = serializedSettings;\n    this._settings = new Settings(serializedSettings);\n    this._onEntriesChanged();\n  }\n\n  _fetch = async (key: string): Promise<void> => {\n    const content = await this._backendMap.get(key);\n\n    if (!this._entries.has(key)) {\n      console.error(\"Entry for fetch doesn't exist anymore. \" + key);\n      return;\n    }\n\n    if (content === undefined) {\n      console.error(\"Key \" + key + \" is missing\");\n      const entry = this._entries.get(key);\n      if (entry != undefined && !entry.isDataLoaded()) {\n        this._entries.delete(key);\n        this._onEntriesChanged();\n      }\n      return;\n    }\n\n    try {\n      if (content === \"\") {\n        const entry = new EntryModel(key, EntryStatus.DELETED, \"\");\n        this._addHistoryItem(entry);\n        this._entries.set(key, entry);\n      } else {\n        const data = JSON.parse(content);\n\n        if (\n          data !== EntryStatus.DELETED &&\n          (data.left == null || data.right == null)\n        ) {\n          throw new Error(\"bad format \" + content);\n        }\n\n        if (\n          data === EntryStatus.DELETED &&\n          this._descriptions.get(key) !== EntryStatus.DELETED\n        ) {\n          this._backendMap.setDescription(key, EntryStatus.DELETED);\n        }\n\n        const entry = new EntryModel(\n          key,\n          data,\n          this._descriptions.get(key) ?? \"\"\n        );\n\n        this._addHistoryItem(entry);\n        this._entries.set(key, entry);\n      }\n    } catch (e) {\n      console.error(e.message + \" \" + key + \" \" + content);\n      const entry = this._entries.get(key);\n      if (entry != undefined && !entry.isDataLoaded()) {\n        this._entries.delete(key);\n        this._onEntriesChanged();\n      }\n      return;\n    }\n\n    this._onEntriesChanged();\n  };\n\n  _getFilteredEntriesArray(): EntryModel[] {\n    return Array.from(this._entries.values())\n      .reverse()\n      .filter((x) => x.data !== EntryStatus.DELETED && x.key !== null);\n  }\n\n  _onEntriesChanged(): void {\n    const entries = this._getFilteredEntriesArray();\n    this._subscriptions.forEach((callback) => {\n      callback(entries, this._settings, {\n        canRedo: this._history.length > this._historyIndex,\n        canUndo: this._history.length > 0 && this._historyIndex > 0,\n      });\n    });\n  }\n}\n"],"sourceRoot":""}