{"version":3,"sources":["EntriesTableModelImpl.js"],"names":["EntriesTableModelImpl","backendMap","authClient","console","assert","BackendMap","addNewItemThrottled","_","throttle","addNewItem","a","omitHistory","_addNewItemMutex","acquire","release","_tryFindVacantEntry","_createNewEntry","entry","onUpdate","clear","setFocused","setInitiallyCollapsed","setCreationTime","Date","now","undo","_historyIndex","_history","old","data","EntryStatus","DELETED","new","_entries","set","key","_sendEntryToBackend","_onEntriesChanged","redo","length","historyItem","sync","_disposed","_authClient","state","GDriveStates","SIGNED_IN","waitForStateChange","_backendMap","getAllKeys","keys","newEntries","Map","forEach","x","has","id","get","description","outdated","EntryModel","delete","size","HIDDEN","LOADING","_descriptions","setDescription","promises","_settings","push","_fetchSettings","reverse","_fetch","Promise","all","onSettingsUpdate","debounce","settings","setSettings","stringify","prevEntry","_addHistoryItem","Mutex","_subscriptions","Set","_syncLoop","setTimeout","content","error","undefined","JSON","parse","left","right","Error","message","isDataLoaded","this","callback","add","_getFilteredEntriesArray","canUndo","canRedo","lastVacantEntry","createKey","newKey","newEntry","slice","descriptionPromise","dataPromise","getSettings","serializedSettings","_serializedSettings","Settings","Array","from","values","filter","entries","EntriesTableModel"],"mappings":"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","file":"static/js/6.794f64c9.chunk.js","sourcesContent":["import { BackendMap } from \"./BackendMap\";\nimport { GDriveStates } from \"./GDriveAuthClient\";\nimport { Settings } from \"./Settings\";\nimport { EntryStatus, EntryModel } from \"./EntryModel\";\nimport _ from \"lodash\";\nimport { Mutex } from \"async-mutex\";\nimport { EntriesTableModel } from \"./EntriesTableModel\";\n\nexport class EntriesTableModelImpl extends EntriesTableModel {\n  constructor(backendMap, authClient) {\n    console.assert(backendMap instanceof BackendMap);\n    super();\n    this._backendMap = backendMap;\n    this._authClient = authClient;\n    this._syncLoop();\n  }\n\n  dispose() {\n    this._disposed = true;\n    this._subscriptions = new Set();\n  }\n\n  subscribe(callback) {\n    this._subscriptions.add(callback);\n    if (this._entries.size > 0)\n      callback(this._getFilteredEntriesArray(), this._settings, {\n        canUndo: false,\n        canRedo: false,\n      });\n  }\n\n  unsubscribe(callback) {\n    this._subscriptions.delete(callback);\n  }\n\n  addNewItemThrottled = _.throttle(() => {\n    this.addNewItem();\n  }, 500);\n\n  addNewItem = async (omitHistory = false) => {\n    let release = await this._addNewItemMutex.acquire();\n\n    const entry = this._tryFindVacantEntry() || (await this._createNewEntry());\n\n    this.onUpdate(\n      entry\n        .clear()\n        .setFocused(true)\n        .setInitiallyCollapsed(true)\n        .setCreationTime(new Date(Date.now())),\n      omitHistory\n    );\n\n    release();\n  };\n\n  // If user deletes entries from top of the table than keys assigned to these\n  // entries can be reused.\n  // This function returns such entry if it exists.\n  _tryFindVacantEntry() {\n    let lastVacantEntry = null;\n    this._entries.forEach((entry) => {\n      if (entry.data === EntryStatus.DELETED) {\n        if (lastVacantEntry == null) lastVacantEntry = entry;\n      } else {\n        lastVacantEntry = null;\n      }\n    });\n\n    return lastVacantEntry;\n  }\n\n  // If there is no deleted entry to reuse the only option is creating a new one.\n  async _createNewEntry() {\n    if (this._entries.has(null)) {\n      return;\n    }\n    this._entries.set(null, new EntryModel(null).delete());\n\n    let newKey = await this._backendMap.createKey();\n\n    if (!this._entries.has(null)) {\n      throw new Error(\"A null key should persist until the new key is created\");\n    }\n\n    let newEntry = new EntryModel(newKey, this._entries.get(null).data, \"\");\n    this._entries.set(newKey, newEntry);\n    await this._sendEntryToBackend(newEntry);\n\n    this._entries.delete(null);\n\n    return newEntry;\n  }\n\n  undo = () => {\n    if (this._historyIndex === 0) return;\n\n    this._historyIndex--;\n\n    let entry = this._history[this._historyIndex].old;\n    if (entry.data !== EntryStatus.DELETED) {\n      entry = entry.setFocused(true);\n      if (this._history[this._historyIndex].new.data === EntryStatus.DELETED) {\n        entry = entry.setInitiallyCollapsed(true);\n      }\n    }\n\n    this._entries.set(entry.key, entry);\n    this._sendEntryToBackend(entry);\n    this._onEntriesChanged();\n  };\n\n  redo = () => {\n    if (this._historyIndex >= this._history.length) return;\n\n    let historyItem = this._history[this._historyIndex++];\n    let entry = historyItem.new;\n    if (entry.data !== EntryStatus.DELETED) {\n      entry = entry.setFocused(true);\n      if (historyItem.old.data === EntryStatus.DELETED) {\n        entry = entry.setInitiallyCollapsed(true);\n      }\n    }\n\n    this._entries.set(entry.key, entry);\n    this._sendEntryToBackend(entry);\n    this._onEntriesChanged();\n  };\n\n  sync = async () => {\n    if (this._disposed) return;\n\n    while (this._authClient.state !== GDriveStates.SIGNED_IN) {\n      await this._authClient.waitForStateChange();\n    }\n\n    let keys = await this._backendMap.getAllKeys();\n\n    let newEntries = new Map();\n\n    keys.forEach((x) => {\n      let entry;\n      if (this._entries.has(x.id)) {\n        entry = this._entries.get(x.id);\n      } else if (x.description === EntryStatus.DELETED) {\n        x.outdated = false;\n        entry = new EntryModel(x.id).delete();\n      } else {\n        x.outdated = true;\n        entry = new EntryModel(\n          x.id,\n          newEntries.size < keys.length - 30\n            ? EntryStatus.HIDDEN\n            : EntryStatus.LOADING,\n          x.description\n        );\n        this._descriptions.set(x.id, x.description);\n      }\n\n      if (x.description !== this._descriptions.get(x.id)) {\n        entry = entry.setDescription(x.description);\n        this._descriptions.set(x.id, x.description);\n      }\n      newEntries.set(x.id, entry);\n    });\n\n    let promises = [];\n    if (this._settings == null) promises.push(this._fetchSettings());\n\n    keys.reverse().forEach((x) => {\n      if (x.outdated && newEntries.get(x.id).data !== EntryStatus.HIDDEN) {\n        promises.push(this._fetch(x.id));\n      }\n    });\n\n    if (this._entries.has(null)) {\n      newEntries.set(null, this._entries.get(null));\n    }\n\n    this._entries = newEntries;\n\n    if (this._entries.size === 0) {\n      await this.addNewItem(true);\n      return;\n    }\n\n    this._onEntriesChanged();\n\n    await Promise.all(promises);\n  };\n\n  onSettingsUpdate = _.debounce((settings) => {\n    this._settings = settings;\n    this._onEntriesChanged();\n    this._backendMap.setSettings(settings.stringify());\n  }, 1000);\n\n  onUpdate = (entry, omitHistory = false) => {\n    if (!this._entries.has(entry.key)) return;\n\n    let prevEntry = this._entries.get(entry.key);\n\n    if (entry.data === EntryStatus.LOADING) {\n      if (prevEntry.data === EntryStatus.HIDDEN) {\n        this._fetch(entry.key);\n        this._entries.set(entry.key, entry);\n      }\n      return;\n    }\n\n    this._sendEntryToBackend(entry);\n    if (!omitHistory) this._addHistoryItem(entry);\n    this._entries.set(entry.key, entry);\n\n    this._onEntriesChanged();\n  };\n\n  _disposed = false;\n  _historyIndex = 0;\n  _history = [];\n  _authClient = null;\n  _backendMap = null;\n  _addNewItemMutex = new Mutex();\n\n  // |_entries| is in reverse order.\n  // It is natural for |Map| to add new items to the end, but\n  // in |EntriesTable| new items belong to the top.\n  _entries = new Map();\n  _settings = null;\n  _descriptions = new Map();\n  _subscriptions = new Set();\n\n  _syncLoop = async () => {\n    await this.sync();\n    setTimeout(this._syncLoop, 15000);\n  };\n\n  _addHistoryItem(newEntry) {\n    if (newEntry.key == null) {\n      throw new Error(\n        \"null key shouldn't have value. There is no point to restore it.\"\n      );\n    }\n\n    if (\n      !this._entries.has(newEntry.key) ||\n      !this._entries.get(newEntry.key).isDataLoaded()\n    ) {\n      return;\n    }\n\n    this._history = this._history.slice(0, this._historyIndex);\n    this._history.push({\n      old: this._entries.has(newEntry.key)\n        ? this._entries.get(newEntry.key)\n        : new EntryModel(newEntry.key).delete(),\n      new: newEntry,\n    });\n    this._historyIndex = this._history.length;\n  }\n\n  async _sendEntryToBackend(entry) {\n    let descriptionPromise = null;\n    if (entry.description !== this._descriptions.get(entry.key)) {\n      descriptionPromise = this._backendMap.setDescription(\n        entry.key,\n        entry.description\n      );\n      this._descriptions.set(entry.key, entry.description);\n    }\n\n    let dataPromise = null;\n    if (entry.isDataLoaded())\n      dataPromise = this._backendMap.set(entry.key, JSON.stringify(entry.data));\n\n    await Promise.all([descriptionPromise, dataPromise]);\n  }\n\n  async _fetchSettings() {\n    const serializedSettings = await this._backendMap.getSettings();\n    if (this._serializedSettings === serializedSettings) return;\n\n    this._serializedSettings = serializedSettings;\n\n    this._settings = new Settings(serializedSettings);\n\n    this._onEntriesChanged();\n  }\n\n  _fetch = async (key) => {\n    let content = await this._backendMap.get(key);\n\n    if (!this._entries.has(key)) {\n      console.error(\"Entry for fetch doesn't exist anymore. \" + key);\n      return;\n    }\n\n    if (content === undefined) {\n      console.error(\"Key \" + key + \" is missing\");\n      this._entries.delete(key);\n      this._onEntriesChanged();\n      return;\n    }\n\n    try {\n      if (content === \"\") {\n        let entry = new EntryModel(key).delete();\n        this._addHistoryItem(entry);\n        this._entries.set(key, entry);\n      } else {\n        const data = JSON.parse(content);\n\n        if (\n          data !== EntryStatus.DELETED &&\n          (data.left == null || data.right == null)\n        ) {\n          throw new Error(\"bad format \" + content);\n        }\n\n        if (\n          data === EntryStatus.DELETED &&\n          this._descriptions.get(key) !== EntryStatus.DELETED\n        ) {\n          this._backendMap.setDescription(key, EntryStatus.DELETED);\n        }\n\n        let entry = new EntryModel(key, data, this._descriptions.get(key));\n\n        this._addHistoryItem(entry);\n        this._entries.set(key, entry);\n      }\n    } catch (e) {\n      console.error(e.message + \" \" + key + \" \" + content);\n      if (!this._entries.get(key).isDataLoaded()) {\n        this._entries.delete(key);\n        this._descriptions.delete(key);\n        this._backendMap.delete(key);\n      }\n    }\n\n    this._onEntriesChanged();\n  };\n\n  _getFilteredEntriesArray() {\n    return Array.from(this._entries.values())\n      .reverse()\n      .filter((x) => x.data !== EntryStatus.DELETED && x.key !== null);\n  }\n\n  _onEntriesChanged() {\n    const entries = this._getFilteredEntriesArray();\n    this._subscriptions.forEach((callback) => {\n      callback(entries, this._settings, {\n        canRedo: this._history.length > this._historyIndex,\n        canUndo: this._history.length > 0 && this._historyIndex > 0,\n      });\n    });\n  }\n}\n"],"sourceRoot":""}